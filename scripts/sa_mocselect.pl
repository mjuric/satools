#!/usr/bin/perl

@mocrecord = (
        'oid',
        'run', 'col', 'field', 'id',
        'rowc', 'colc',

        'mjd', 'ra_o', 'dec_o', 'lambda_o', 'beta_o', 'phi_o',
        'vmu_o', 'vmuErr_o', 'vnu_o', 'vnuErr_o',
        'vra_o', 'vdec_o',

        'u', 'uErr', 'g', 'gErr', 'r', 'rErr', 'i', 'iErr', 'z', 'zErr', 'b', 'bErr', 'V', 'B',

        'isIdentified',
        'numeration',
        'designation',
        'iapp', 'napp', 'flags',

        'ra_c', 'dec_c', 'mag_c',
        'R', 'geo_dist', 'phase',

        'oe_cat',
        'H', 'G', 'arc', 'epoch', 'a', 'e', 'inc', 'lan', 'aop', 'M',

        'pe_cat',
        'ap', 'ep', 'sinip'
);

sub mocString
{
	$s = "";

	# moving object record
	$s .= sprintf("%-6s %5d %1d %4d %5d %8.3f %8.3f  ", $oid, $run, $col, $field, $id, $rowc, $colc);

	# time in MJD and position in deg (equatorial and ecliptic)
	$s .= sprintf(" %12.6f %10.6f %10.6f %10.6f %10.6f %11.6f ", $mjd, $ra_o, $dec_o, $lambda_o, $beta_o, $phi_o);

	# velocities
	$s .= sprintf(" %+6.4f %6.4f %+6.4f %6.4f %+6.4f %+6.4f ", $vmu_o, $vmuErr_o, $vnu_o, $vnuErr_o, $vra_o, $vdec_o);

	# SDSS magnitudes
	$s .= sprintf(" %5.2f %4.2f %5.2f %4.2f %5.2f %4.2f %5.2f %4.2f %5.2f %4.2f %5.2f %4.2f ",
		$u, $uErr, $g, $gErr, $r, $rErr, $i, $iErr, $z, $zErr, $b, $bErr);

	# Johnson magnitudes
	$s .= sprintf(" %5.2f %5.2f ", $V, $B);


	
	# identification information
	$s .= sprintf("%1d %5d %-20s %2d %2d %08x ", $isIdentified, $numeration, $designation, $iapp, $napp, $flags);

	# identification data
	$s .= sprintf(" %10.6f %10.6f %5.2f ", $ra_c, $dec_c, $mag_c);
	$s .= sprintf(" %7.3f %7.3f %5.2f ", $R, $geo_dist, $phase);



	# orbital elements
	$s .= sprintf(" %-20s %5.2f %4.2f %5.0f ", $oe_cat, $H, $G, $arc);
	$s .= sprintf(" %12.6f %12.8f %10.8f %10.6f %10.6f %10.6f %10.6f ", $epoch, $a, $e, $inc, $lan, $aop, $M);

	# proper elements
	$s .= sprintf(" %-20s %12.8f %10.8f %10.6f", $pe_cat, $ap, $ep, $sinip);

	return $s;
}


#
# 'MOC SQL' routines
#
sub query(&$) {
	my ($filter, $moc) = @_;

	my $rmoc = [];
	$idx = 0;
	for $rec (@{$moc}) {
		# localize this record for easy acccess by variables
		# and initialize the reference to record copy which we'll return
		my $record = {};
		foreach $fld (@mocrecord) { $$fld = ${$record}{$fld} = ${$rec}{$fld}; }

		# call filtering subroutine
		# the filtering subroutine has all @mocrecord variables accessible to itself
		# plus the $idx and $record automatic variables
		# -- word of caution: at this point, $record is _empty_. If you want to change
		# the values of individual fields, use local variables. However, $record is a valid
		# reference to the record which will be returned (for the use of this, 
		# see sub groupby())
		next if not &{$filter};

		# collect @mocrecord fields into the record hash
		foreach(@mocrecord) { ${$record}{$fld} = $$fld; }
		push @{$rmoc}, $ret;

		$idx++;
	}
	return $rmoc;
}

sub filter(&$) {
	my ($filt, $moc) = @_;
	my $rmoc = &query;

	@{$moc} = @{$rmoc};
}

sub unique(&$) {
	my ($expr, $moc) = @_;
	my %uniq;
	return query { 
		$key = &{$expr};
		$r = not defined $uniq{$key};
		$uniq{$key} = 1;
		return $r;
	} $moc;
}

sub groupby(&$) {
	my ($expr, $moc) = @_;
	my $grouped = {};
	query {
		$key = &{$expr};
		push @{${$grouped}{$key}}, $record;
	} $moc;
	return $grouped;
}

sub aggregate(&$) {
	sub do_aggregate(&$) {
		my ($expr, $moc) = @_;
		my $grouped = {};

		%AGG = ();
		my $AGG = 0;
		query {
			$AGG += &{$expr};
		} $moc;

		if(not scalar keys %AGG) {
			print STDERR "  result = $AGG\n";
			return $AGG;
		} else {
			print "  ";
			for $k (keys %AGG) { print STDERR "$k = $AGG{$k}, "; }
			print STDERR "\n";
			return { %AGG };
		}
	}

	my ($expr, $moc) = @_;
	my $grouped = {};

	# if an array was passed
	if(ref($moc) eq "ARRAY") { return &do_aggregate; }

	# if a hash was passed (probably generated by a group-by statement)
	my %ret;
	for $k (keys %{$moc}) {
		print "  $k :";
		$ret{$k} = do_aggregate {
			&{$expr};
		} ${$moc}{$k};
	}
	return { %ret };
}

sub load {
	# load the file
	$mocfile = shift;
	open(MOC, $mocfile) or die "Cannot open MOC catalog [$mocfile]";

	print STDERR "  Loading MOC [$mocfile] ... ";

	my $moc = [];
	my $idx = 0;
	while(<MOC>) {
		@r = split /\s+/;
		foreach $k (@mocrecord) { ${$moc}[$idx]{$k} = shift @r; }
		$idx++;
#		last if $idx==1000;
	}

	print STDERR scalar(@{$moc}) . " records.\n";
	
	close(MOC);
	return $moc;
}

sub output {
	my $fh = shift;
	my $moc = shift;
	filter { print $fh mocString() . "\n"; } $moc;
}

sub save {
	my ($fname, $moc) = @_;
	open(RMOC, ">$fname") or die "Cannot open [$fname] for writing! Aborting query.\n";
	output(\*RMOC, $moc);
	close(RMOC);
}

sub echo {
	my $moc = shift;
	if(not @_) { output(\*STDOUT, $moc); }
	else { # list of fields to print follows in @_
		for $r (@{$moc}) {
			for $f (@_) { printf STDERR "%12s", ${$r}{$f}; }
			print "\n";
		}
	}
}

sub status {
	for $moc (@_) { print STDERR "  contains " . scalar(@{$moc}) . " records.\n"; }
}

sub quit {
	exit(0);
}

############################

$moc = [];
for $f (@ARGV) { my $r = load($f); push @{$moc}, @{$r}; }

print STDERR "  Catalog with " . scalar(@{$moc}) . " records total loaded and ready in \$moc.\n";

$|=1; # flushing off
while(1) {
	print STDERR "MOCQL> ";
	last if not defined ($_ = <STDIN>);

	eval; warn $@ if $@;
}

#
# Print out the transform
#

filter { print mocString() . "\n"; } $moc;
